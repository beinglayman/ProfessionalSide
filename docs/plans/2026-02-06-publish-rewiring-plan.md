# Career Story Publishing & Distribution — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Wire career stories to Profile (brag document), Network (follow-based feed), and PublishModal (ceremony).

**Architecture:** Backend-first. Prisma migration adds columns + Follow model. Frontend renames visibility, builds PublishModal, rewires profile page, adds feed. TDD with vitest.

**Tech Stack:** Prisma/PostgreSQL, Express, React, React Query, Radix Dialog, Tailwind, vitest

**Design doc:** `docs/plans/2026-02-06-publish-rewiring-design.md`

---

## Task 1: Visibility Alignment — Frontend Type Rename

Rename `'public'` → `'network'` in frontend types to match backend/DB.

**Files:**
- Modify: `src/types/career-stories.ts:233`
- Modify: `backend/src/controllers/career-stories.controller.ts:1119`

**Step 1: Update frontend StoryVisibility type**

In `src/types/career-stories.ts`, line 233, change:

```typescript
// BEFORE
export type StoryVisibility = 'private' | 'workspace' | 'public';

// AFTER
export type StoryVisibility = 'private' | 'workspace' | 'network';
```

**Step 2: Fix controller validation array**

In `backend/src/controllers/career-stories.controller.ts`, line 1119, change:

```typescript
// BEFORE
if (!visibility || !['public', 'workspace', 'private'].includes(visibility)) {

// AFTER
if (!visibility || !['network', 'workspace', 'private'].includes(visibility)) {
```

**Step 3: Search for any other `'public'` visibility references and fix them**

Run: `grep -rn "'public'" src/ --include="*.ts" --include="*.tsx" | grep -i visib`

Fix any hits that refer to story visibility.

**Step 4: Run TypeScript compiler to catch breakages**

Run: `npx tsc --noEmit`

Expected: No errors (or only pre-existing ones).

**Step 5: Commit**

```bash
git add src/types/career-stories.ts backend/src/controllers/career-stories.controller.ts
git commit -m "fix: align visibility naming to 'network' across frontend and backend"
```

---

## Task 2: Prisma Migration — New CareerStory Columns

Add `archetype`, `category`, `role`, `journalEntryId` to CareerStory model.

**Files:**
- Modify: `backend/prisma/schema.prisma` (CareerStory model, lines 1415-1465)
- Modify: `backend/prisma/schema.prisma` (JournalEntry model, ~line 471, add relation)
- Create: Migration file (auto-generated by `prisma migrate dev`)

**Step 1: Add new fields to CareerStory model**

In `backend/prisma/schema.prisma`, inside the CareerStory model (after line 1452, before `createdAt`):

```prisma
  // Story classification
  archetype      String?  // firefighter, architect, diplomat, multiplier, detective, pioneer, turnaround, preventer
  category       String?  // projects-impact, leadership, growth, external (brag doc category)
  role           String?  // led, contributed, participated (auto-detected by LLM)

  // Provenance: link back to source journal entry
  journalEntryId String?
  journalEntry   JournalEntry? @relation(fields: [journalEntryId], references: [id])
```

**Step 2: Add reverse relation on JournalEntry model**

In `backend/prisma/schema.prisma`, inside the JournalEntry model (after line 484, before the `@@index` lines):

```prisma
  // Career stories promoted from this journal entry
  careerStories CareerStory[]
```

**Step 3: Add index for journalEntryId**

Inside CareerStory model, after the existing `@@index` lines (after line 1463):

```prisma
  @@index([journalEntryId])
```

**Step 4: Generate and run migration**

Run: `cd backend && npx prisma migrate dev --name add-story-classification-fields`

Expected: Migration succeeds. 4 nullable columns added, no data loss.

**Step 5: Verify with Prisma Studio**

Run: `cd backend && npx prisma studio`

Check: CareerStory table now has archetype, category, role, journalEntryId columns. All existing rows have `null` for new fields.

**Step 6: Commit**

```bash
git add backend/prisma/schema.prisma backend/prisma/migrations/
git commit -m "feat: add archetype, category, role, journalEntryId to CareerStory model"
```

---

## Task 3: Prisma Migration — Follow Model

Create the `Follow` model for one-way follows with 100-cap.

**Files:**
- Modify: `backend/prisma/schema.prisma` (add Follow model)
- Modify: `backend/prisma/schema.prisma` (add relations on User model)
- Create: Migration file (auto-generated)

**Step 1: Add Follow model to schema**

In `backend/prisma/schema.prisma`, after the CareerStory model:

```prisma
model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}
```

**Step 2: Add Follow relations on User model**

Find the User model in schema.prisma and add these relation fields:

```prisma
  // Follow relationships (one-way, capped at 100)
  following  Follow[] @relation("Follower")
  followers  Follow[] @relation("Following")
```

**Step 3: Run migration**

Run: `cd backend && npx prisma migrate dev --name add-follow-model`

Expected: Migration succeeds. New `follows` table created.

**Step 4: Commit**

```bash
git add backend/prisma/schema.prisma backend/prisma/migrations/
git commit -m "feat: add Follow model for one-way follow with 100-cap"
```

---

## Task 4: Follow Service — Backend CRUD + 100-Cap

Create follow service with follow/unfollow/list operations and 100-cap enforcement.

**Files:**
- Create: `backend/src/services/follow.service.ts`
- Test: `backend/src/services/follow.service.test.ts`

**Step 1: Write the failing tests**

Create `backend/src/services/follow.service.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, afterEach } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { FollowService } from './follow.service';

const prisma = new PrismaClient();
const FOLLOWER_ID = 'test-follow-user-a';
const FOLLOWING_ID = 'test-follow-user-b';

async function ensureTestUsers() {
  for (const id of [FOLLOWER_ID, FOLLOWING_ID]) {
    const existing = await prisma.user.findUnique({ where: { id } });
    if (!existing) {
      await prisma.user.create({
        data: { id, email: `${id}@test.com`, name: id, password: 'hash' },
      });
    }
  }
}

async function cleanup() {
  await prisma.follow.deleteMany({
    where: { followerId: { startsWith: 'test-follow-' } },
  });
}

beforeAll(async () => { await ensureTestUsers(); });
afterEach(async () => { await cleanup(); });
afterAll(async () => {
  await cleanup();
  await prisma.$disconnect();
});

describe('FollowService', () => {
  const service = new FollowService();

  it('follows a user', async () => {
    const result = await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    expect(result.success).toBe(true);
  });

  it('prevents duplicate follows', async () => {
    await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    const result = await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    expect(result.success).toBe(false);
    expect(result.error).toContain('already');
  });

  it('prevents self-follow', async () => {
    const result = await service.follow(FOLLOWER_ID, FOLLOWER_ID);
    expect(result.success).toBe(false);
    expect(result.error).toContain('yourself');
  });

  it('unfollows a user', async () => {
    await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    const result = await service.unfollow(FOLLOWER_ID, FOLLOWING_ID);
    expect(result.success).toBe(true);
  });

  it('lists following', async () => {
    await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    const result = await service.getFollowing(FOLLOWER_ID);
    expect(result).toHaveLength(1);
    expect(result[0].followingId).toBe(FOLLOWING_ID);
  });

  it('lists followers', async () => {
    await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    const result = await service.getFollowers(FOLLOWING_ID);
    expect(result.data).toHaveLength(1);
    expect(result.data[0].followerId).toBe(FOLLOWER_ID);
  });

  it('enforces 100-follow cap', async () => {
    // Create 100 users and follow them
    const userIds: string[] = [];
    for (let i = 0; i < 100; i++) {
      const id = `test-follow-cap-${i}`;
      userIds.push(id);
      const existing = await prisma.user.findUnique({ where: { id } });
      if (!existing) {
        await prisma.user.create({
          data: { id, email: `${id}@test.com`, name: id, password: 'hash' },
        });
      }
      await service.follow(FOLLOWER_ID, id);
    }

    // 101st should fail
    const extraId = 'test-follow-cap-extra';
    const existing = await prisma.user.findUnique({ where: { id: extraId } });
    if (!existing) {
      await prisma.user.create({
        data: { id: extraId, email: `${extraId}@test.com`, name: extraId, password: 'hash' },
      });
    }
    const result = await service.follow(FOLLOWER_ID, extraId);
    expect(result.success).toBe(false);
    expect(result.error).toContain('100');

    // Cleanup cap users
    await prisma.follow.deleteMany({ where: { followerId: FOLLOWER_ID } });
    await prisma.user.deleteMany({ where: { id: { startsWith: 'test-follow-cap-' } } });
  });

  it('returns follow count', async () => {
    await service.follow(FOLLOWER_ID, FOLLOWING_ID);
    const count = await service.getFollowingCount(FOLLOWER_ID);
    expect(count).toBe(1);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd backend && npx vitest run src/services/follow.service.test.ts`

Expected: FAIL — module not found.

**Step 3: Implement FollowService**

Create `backend/src/services/follow.service.ts`:

```typescript
import { prisma } from '../lib/prisma';

const MAX_FOLLOWING = 100;

interface FollowResult {
  success: boolean;
  error?: string;
}

interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
}

export class FollowService {
  async follow(followerId: string, followingId: string): Promise<FollowResult> {
    if (followerId === followingId) {
      return { success: false, error: 'Cannot follow yourself' };
    }

    // Check cap
    const count = await prisma.follow.count({ where: { followerId } });
    if (count >= MAX_FOLLOWING) {
      return { success: false, error: `You can follow up to ${MAX_FOLLOWING} people. Unfollow someone first.` };
    }

    // Check duplicate
    const existing = await prisma.follow.findUnique({
      where: { followerId_followingId: { followerId, followingId } },
    });
    if (existing) {
      return { success: false, error: 'You already follow this user' };
    }

    await prisma.follow.create({ data: { followerId, followingId } });
    return { success: true };
  }

  async unfollow(followerId: string, followingId: string): Promise<FollowResult> {
    const existing = await prisma.follow.findUnique({
      where: { followerId_followingId: { followerId, followingId } },
    });
    if (!existing) {
      return { success: false, error: 'Not following this user' };
    }

    await prisma.follow.delete({
      where: { followerId_followingId: { followerId, followingId } },
    });
    return { success: true };
  }

  async getFollowing(followerId: string) {
    return prisma.follow.findMany({
      where: { followerId },
      include: { following: { select: { id: true, name: true, email: true } } },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getFollowers(
    followingId: string,
    page = 1,
    pageSize = 20
  ): Promise<PaginatedResult<{ followerId: string; createdAt: Date }>> {
    const [data, total] = await Promise.all([
      prisma.follow.findMany({
        where: { followingId },
        include: { follower: { select: { id: true, name: true, email: true } } },
        orderBy: { createdAt: 'desc' },
        skip: (page - 1) * pageSize,
        take: pageSize,
      }),
      prisma.follow.count({ where: { followingId } }),
    ]);
    return { data, total, page, pageSize };
  }

  async getFollowingCount(followerId: string): Promise<number> {
    return prisma.follow.count({ where: { followerId } });
  }

  async getFollowerCount(followingId: string): Promise<number> {
    return prisma.follow.count({ where: { followingId } });
  }

  async isFollowing(followerId: string, followingId: string): Promise<boolean> {
    const follow = await prisma.follow.findUnique({
      where: { followerId_followingId: { followerId, followingId } },
    });
    return !!follow;
  }
}
```

**Step 4: Run tests to verify they pass**

Run: `cd backend && npx vitest run src/services/follow.service.test.ts`

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add backend/src/services/follow.service.ts backend/src/services/follow.service.test.ts
git commit -m "feat: add FollowService with 100-cap, follow/unfollow/list operations"
```

---

## Task 5: Follow API Routes

Wire FollowService to Express routes.

**Files:**
- Modify: `backend/src/routes/network.routes.ts` (replace placeholder /followers, add new routes)

**Step 1: Add follow routes**

In `backend/src/routes/network.routes.ts`, add imports at top:

```typescript
import { FollowService } from '../services/follow.service';
```

Replace the placeholder `/followers` route (lines 437-461) and add new routes:

```typescript
// =============================================================================
// FOLLOW ROUTES (one-way, 100-cap)
// =============================================================================

const followService = new FollowService();

// Follow a user
router.post('/follow/:userId', async (req: Request, res: Response) => {
  try {
    const followerId = req.user!.id;
    const followingId = req.params.userId;
    const result = await followService.follow(followerId, followingId);
    if (!result.success) {
      return sendError(res, result.error || 'Follow failed', 400);
    }
    sendSuccess(res, result, 'Followed successfully');
  } catch (error) {
    console.error('Error following user:', error);
    sendError(res, 'Failed to follow user', 500);
  }
});

// Unfollow a user
router.delete('/follow/:userId', async (req: Request, res: Response) => {
  try {
    const followerId = req.user!.id;
    const followingId = req.params.userId;
    const result = await followService.unfollow(followerId, followingId);
    if (!result.success) {
      return sendError(res, result.error || 'Unfollow failed', 400);
    }
    sendSuccess(res, result, 'Unfollowed successfully');
  } catch (error) {
    console.error('Error unfollowing user:', error);
    sendError(res, 'Failed to unfollow user', 500);
  }
});

// List who I follow (max 100)
router.get('/following', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const following = await followService.getFollowing(userId);
    sendSuccess(res, { data: following, total: following.length });
  } catch (error) {
    console.error('Error fetching following:', error);
    sendError(res, 'Failed to fetch following list', 500);
  }
});

// List who follows me (paginated)
router.get('/followers', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const page = parseInt(req.query.page as string) || 1;
    const pageSize = parseInt(req.query.pageSize as string) || 20;
    const result = await followService.getFollowers(userId, page, pageSize);
    sendSuccess(res, result, 'Followers retrieved successfully');
  } catch (error) {
    console.error('Error fetching followers:', error);
    sendError(res, 'Failed to fetch followers', 500);
  }
});

// Check if I follow a specific user
router.get('/follow/:userId/status', async (req: Request, res: Response) => {
  try {
    const followerId = req.user!.id;
    const followingId = req.params.userId;
    const isFollowing = await followService.isFollowing(followerId, followingId);
    const followingCount = await followService.getFollowingCount(followerId);
    sendSuccess(res, { isFollowing, followingCount, maxFollowing: 100 });
  } catch (error) {
    console.error('Error checking follow status:', error);
    sendError(res, 'Failed to check follow status', 500);
  }
});
```

**Step 2: Verify backend compiles**

Run: `cd backend && npx tsc --noEmit`

Expected: No new errors.

**Step 3: Commit**

```bash
git add backend/src/routes/network.routes.ts
git commit -m "feat: add follow/unfollow/list API routes with 100-cap"
```

---

## Task 6: Store Archetype + JournalEntryId on Story Creation

Update wizard and service to persist new fields when creating stories.

**Files:**
- Modify: `backend/src/services/story-wizard.service.ts:496-509` (add archetype + journalEntryId)
- Modify: `backend/src/services/career-stories/career-story.service.ts:706-719` (add archetype)
- Modify: `backend/src/services/career-stories/career-story.service.ts:1154-1162` (add archetype on regenerate)
- Modify: `backend/src/controllers/career-stories.schemas.ts:103-115` (add archetype to schema)

**Step 1: Update wizard generateStory to store archetype + journalEntryId**

In `backend/src/services/story-wizard.service.ts`, at the `prisma.careerStory.create` call (lines 496-509), add `archetype` and `journalEntryId`:

```typescript
// BEFORE (lines 496-509)
const story = await prisma.careerStory.create({
  data: {
    userId,
    sourceMode: this.isDemoMode ? 'demo' : 'production',
    title: entry.title || 'Career Story',
    activityIds: entry.activityIds,
    framework,
    sections: sections as unknown as Prisma.InputJsonValue,
    generatedAt: new Date(),
    needsRegeneration: false,
    visibility: 'private',
    isPublished: false,
  },
});

// AFTER
const story = await prisma.careerStory.create({
  data: {
    userId,
    sourceMode: this.isDemoMode ? 'demo' : 'production',
    title: entry.title || 'Career Story',
    activityIds: entry.activityIds,
    framework,
    sections: sections as unknown as Prisma.InputJsonValue,
    generatedAt: new Date(),
    needsRegeneration: false,
    visibility: 'private',
    isPublished: false,
    archetype: archetype || null,
    journalEntryId: journalEntryId || null,
  },
});
```

Note: Check how `archetype` and `journalEntryId` are available in scope. The wizard's `generateStory` method receives `archetype` in its params (from `WizardGenerateRequest`). The `journalEntryId` is also a parameter — find it in the method signature and thread it through.

**Step 2: Update career-story.service.ts createStory**

In `backend/src/services/career-stories/career-story.service.ts`, at the `prisma.careerStory.create` call (lines 706-719), add archetype if available in input:

```typescript
// Add to the data object:
archetype: input.archetype || null,
```

**Step 3: Update regenerate to store archetype**

In `backend/src/services/career-stories/career-story.service.ts`, at the `prisma.careerStory.update` call (lines 1154-1162):

```typescript
// BEFORE
const updated = await prisma.careerStory.update({
  where: { id: storyId },
  data: {
    framework: nextFramework,
    sections: sections as unknown as Prisma.InputJsonValue,
    needsRegeneration: false,
    generatedAt: new Date(),
  },
});

// AFTER — add archetype if provided
const updated = await prisma.careerStory.update({
  where: { id: storyId },
  data: {
    framework: nextFramework,
    sections: sections as unknown as Prisma.InputJsonValue,
    needsRegeneration: false,
    generatedAt: new Date(),
    ...(archetype ? { archetype } : {}),
  },
});
```

Check how `archetype` flows into the regenerate method — it likely needs to be added to the method params and threaded from the controller.

**Step 4: Add archetype to regenerateStorySchema**

In `backend/src/controllers/career-stories.schemas.ts`, add archetype to the schema (after line 105):

```typescript
export const regenerateStorySchema = z.object({
  framework: frameworkNameSchema.optional(),
  style: writingStyleSchema.optional(),
  archetype: z.enum([
    'firefighter', 'architect', 'diplomat', 'multiplier',
    'detective', 'pioneer', 'turnaround', 'preventer',
  ]).optional(),
  userPrompt: z
    .string()
    .max(USER_PROMPT_MAX_LENGTH)
    .optional()
    .transform((val) => {
      if (!val) return undefined;
      const trimmed = val.trim();
      return trimmed.length === 0 ? undefined : trimmed;
    }),
}).strict();
```

**Step 5: Verify backend compiles**

Run: `cd backend && npx tsc --noEmit`

**Step 6: Run existing tests to ensure nothing breaks**

Run: `cd backend && npx vitest run src/services/career-stories/career-story.service.test.ts`

Expected: Existing tests still pass.

**Step 7: Commit**

```bash
git add backend/src/services/story-wizard.service.ts backend/src/services/career-stories/career-story.service.ts backend/src/controllers/career-stories.schemas.ts
git commit -m "feat: store archetype and journalEntryId on story creation and regeneration"
```

---

## Task 7: Update PublishedStory API Response

Add new fields to the published stories endpoint response.

**Files:**
- Modify: `backend/src/services/career-stories/story-publishing.service.ts:45-56` (interface)
- Modify: `backend/src/services/career-stories/story-publishing.service.ts` (mapStory method)

**Step 1: Write the failing test**

Add to `backend/src/services/career-stories/story-publishing.service.test.ts`:

```typescript
it('includes archetype, category, role, journalEntryId in published story', async () => {
  await prisma.careerStory.create({
    data: {
      userId: TEST_USER_ID,
      sourceMode: 'demo',
      title: 'Classified Story',
      framework: 'STAR',
      sections: { situation: { summary: 'test' } },
      activityIds: ['a1'],
      isPublished: true,
      visibility: 'network',
      publishedAt: new Date(),
      archetype: 'architect',
      category: 'projects-impact',
      role: 'led',
    },
  });

  const service = createStoryPublishingService(true);
  const result = await service.getPublishedStories(TEST_USER_ID, TEST_USER_ID);
  const story = result.stories[0];
  expect(story.archetype).toBe('architect');
  expect(story.category).toBe('projects-impact');
  expect(story.role).toBe('led');
});
```

**Step 2: Run test to verify it fails**

Run: `cd backend && npx vitest run src/services/career-stories/story-publishing.service.test.ts`

Expected: FAIL — `archetype` is undefined on the mapped story.

**Step 3: Update PublishedStory interface**

In `backend/src/services/career-stories/story-publishing.service.ts`, update the interface (lines 45-56):

```typescript
export interface PublishedStory {
  id: string;
  title: string;
  publishedAt: Date | null;
  visibility?: Visibility;
  framework?: string;
  sections?: unknown;
  activityIds?: string[];
  isPublished?: boolean;
  needsRegeneration?: boolean;
  generatedAt?: Date | null;
  archetype?: string | null;
  category?: string | null;
  role?: string | null;
  journalEntryId?: string | null;
}
```

**Step 4: Update mapStory method to include new fields**

Find the `mapStory` method in the same file and add the new fields to the return object:

```typescript
archetype: story.archetype,
category: story.category,
role: story.role,
journalEntryId: story.journalEntryId,
```

**Step 5: Run test to verify it passes**

Run: `cd backend && npx vitest run src/services/career-stories/story-publishing.service.test.ts`

Expected: All tests PASS.

**Step 6: Commit**

```bash
git add backend/src/services/career-stories/story-publishing.service.ts backend/src/services/career-stories/story-publishing.service.test.ts
git commit -m "feat: include archetype, category, role, journalEntryId in published story API response"
```

---

## Task 8: Frontend Types — New Types + CareerStory Update

Add BragDocCategory, StoryRole types and update CareerStory interface.

**Files:**
- Modify: `src/types/career-stories.ts`
- Modify: `src/components/career-stories/constants.ts`

**Step 1: Add new types to career-stories.ts**

After line 233 (`StoryVisibility` type), add:

```typescript
export type BragDocCategory =
  | 'projects-impact'
  | 'leadership'
  | 'growth'
  | 'external';

export type StoryRole = 'led' | 'contributed' | 'participated';
```

**Step 2: Update CareerStory interface**

Add new optional fields to the CareerStory interface (after line 254, before the closing `}`):

```typescript
  archetype?: StoryArchetype | null;
  category?: BragDocCategory | null;
  role?: StoryRole | null;
  journalEntryId?: string | null;
```

**Step 3: Add BRAG_DOC_CATEGORIES constant**

In `src/components/career-stories/constants.ts`, add after the ARCHETYPE_GROUPS section:

```typescript
// =============================================================================
// BRAG DOCUMENT CATEGORIES
// =============================================================================

import type { BragDocCategory } from '../../types/career-stories';

export const BRAG_DOC_CATEGORIES: { value: BragDocCategory; label: string; description: string }[] = [
  { value: 'projects-impact', label: 'Projects & Impact', description: 'Shipped features, solved problems, built systems' },
  { value: 'leadership', label: 'Leadership & Collaboration', description: 'Mentoring, cross-team alignment, hiring' },
  { value: 'growth', label: 'Growth & Learning', description: 'New skills, domain expertise, certifications' },
  { value: 'external', label: 'External', description: 'Talks, blog posts, open source, community' },
];
```

**Step 4: Verify TypeScript compiles**

Run: `npx tsc --noEmit`

**Step 5: Commit**

```bash
git add src/types/career-stories.ts src/components/career-stories/constants.ts
git commit -m "feat: add BragDocCategory, StoryRole types and BRAG_DOC_CATEGORIES constant"
```

---

## Task 9: PublishModal Component

Create the publish ceremony modal with category picker and "Publish to Network" action.

**Files:**
- Create: `src/components/career-stories/PublishModal.tsx`
- Reference: `src/components/career-stories/FormatSwitchModal.tsx` (pattern)
- Reference: `src/components/ui/dialog.tsx` (Radix Dialog)

**Step 1: Create PublishModal component**

Create `src/components/career-stories/PublishModal.tsx`:

```tsx
/**
 * PublishModal Component
 *
 * Publish ceremony for career stories. Left panel: story preview.
 * Right panel: category picker + visibility explainer + career quote.
 * Same weight as FormatSwitchModal — publishing is a deliberate act.
 */

import React, { useState, useMemo } from 'react';
import { Globe, Lock, Heart } from 'lucide-react';
import { cn } from '../../lib/utils';
import { CareerStory, BragDocCategory, NarrativeFramework } from '../../types/career-stories';
import { NARRATIVE_FRAMEWORKS, BRAG_DOC_CATEGORIES, CAREER_QUOTES } from './constants';
import { Button } from '../ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '../ui/dialog';

interface PublishModalProps {
  isOpen: boolean;
  onClose: () => void;
  story: CareerStory;
  onPublish: (category: BragDocCategory) => Promise<void>;
  isPublishing: boolean;
}

function getPreviewSections(story: CareerStory): { label: string; text: string }[] {
  const frameworkInfo = NARRATIVE_FRAMEWORKS[story.framework];
  if (!frameworkInfo) return [];
  return frameworkInfo.sections
    .map((key) => {
      const section = story.sections?.[key];
      if (!section?.summary) return null;
      return { label: key.charAt(0).toUpperCase() + key.slice(1), text: section.summary };
    })
    .filter(Boolean) as { label: string; text: string }[];
}

function estimateSpeakingTime(story: CareerStory): string {
  const allText = Object.values(story.sections || {}).map(s => s?.summary || '').join(' ');
  const words = allText.trim().split(/\s+/).length;
  const seconds = Math.ceil((words / 150) * 60);
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function extractKeyMetrics(story: CareerStory): string[] {
  const allText = Object.values(story.sections || {}).map(s => s?.summary || '').join(' ');
  const metricPattern = /(\d+(?:\.\d+)?[%xX]|\$\d+(?:,\d{3})*(?:\.\d+)?[KMB]?|\d+(?:,\d{3})*\s*(?:ms|seconds?|hours?|days?|users?))/gi;
  const matches = allText.match(metricPattern) || [];
  return [...new Set(matches)].slice(0, 3);
}

export function PublishModal({ isOpen, onClose, story, onPublish, isPublishing }: PublishModalProps) {
  const [selectedCategory, setSelectedCategory] = useState<BragDocCategory>(
    (story.category as BragDocCategory) || 'projects-impact'
  );

  const sections = useMemo(() => getPreviewSections(story), [story]);
  const speakingTime = useMemo(() => estimateSpeakingTime(story), [story]);
  const metrics = useMemo(() => extractKeyMetrics(story), [story]);
  const frameworkInfo = NARRATIVE_FRAMEWORKS[story.framework];

  // Random publishing-themed quote
  const quote = useMemo(() => {
    const publishingQuotes = CAREER_QUOTES.filter(q => q.theme === 'Publishing Your Work');
    return publishingQuotes[Math.floor(Math.random() * publishingQuotes.length)];
  }, []);

  const handlePublish = async () => {
    await onPublish(selectedCategory);
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="max-w-3xl max-h-[85vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle>Publish to Network</DialogTitle>
          <DialogDescription>
            Choose a category and publish your story to your profile and followers' feeds.
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 p-1">
            {/* Left panel: Story preview */}
            <div className="space-y-4">
              <div>
                <h3 className="font-semibold text-gray-900 text-lg">{story.title}</h3>
                <div className="flex items-center gap-2 mt-1">
                  <span className="px-1.5 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-600">
                    {frameworkInfo?.label || story.framework}
                  </span>
                  {story.archetype && (
                    <span className="px-1.5 py-0.5 rounded text-xs font-medium bg-purple-50 text-purple-700 capitalize">
                      {story.archetype}
                    </span>
                  )}
                  {story.role && (
                    <span className="px-1.5 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-700 capitalize">
                      {story.role}
                    </span>
                  )}
                </div>
                <div className="flex items-center gap-2 mt-2 text-xs text-gray-500">
                  <span>{story.activityIds.length} activities</span>
                  <span className="text-gray-300">•</span>
                  <span>~{speakingTime}</span>
                </div>
              </div>

              {/* Key metrics */}
              {metrics.length > 0 && (
                <div className="flex gap-1.5">
                  {metrics.map((metric, idx) => (
                    <span key={idx} className="px-1.5 py-0.5 text-[10px] font-semibold bg-primary-50 text-primary-700 rounded">
                      {metric}
                    </span>
                  ))}
                </div>
              )}

              {/* Section summaries */}
              <div className="space-y-3">
                {sections.map(({ label, text }) => (
                  <div key={label}>
                    <h4 className="text-xs font-semibold text-gray-500 uppercase tracking-wide">{label}</h4>
                    <p className="text-sm text-gray-700 mt-0.5 line-clamp-3">{text}</p>
                  </div>
                ))}
              </div>
            </div>

            {/* Right panel: Publish options */}
            <div className="space-y-6">
              {/* Category picker */}
              <div>
                <label className="text-sm font-medium text-gray-700">Profile Category</label>
                <p className="text-xs text-gray-500 mt-0.5 mb-2">Where this story appears on your brag document</p>
                <div className="space-y-2">
                  {BRAG_DOC_CATEGORIES.map((cat) => (
                    <button
                      key={cat.value}
                      onClick={() => setSelectedCategory(cat.value)}
                      className={cn(
                        'w-full text-left px-3 py-2 rounded-lg border transition-colors',
                        selectedCategory === cat.value
                          ? 'border-primary-500 bg-primary-50'
                          : 'border-gray-200 hover:border-gray-300'
                      )}
                    >
                      <div className="text-sm font-medium text-gray-900">{cat.label}</div>
                      <div className="text-xs text-gray-500">{cat.description}</div>
                    </button>
                  ))}
                </div>
              </div>

              {/* Visibility explainer */}
              <div className="flex items-start gap-2 p-3 rounded-lg bg-blue-50 border border-blue-100">
                <Globe className="w-4 h-4 text-blue-500 mt-0.5 flex-shrink-0" />
                <div>
                  <div className="text-sm font-medium text-blue-900">Who will see this</div>
                  <div className="text-xs text-blue-700 mt-0.5">
                    All inChronicle users can see this on your profile and in their feed.
                  </div>
                </div>
              </div>

              {/* Career quote */}
              {quote && (
                <div className="p-3 rounded-lg bg-gray-50 border border-gray-100">
                  <div className="flex items-start gap-2">
                    <Heart className="w-3.5 h-3.5 text-gray-400 mt-0.5 flex-shrink-0" />
                    <div>
                      <p className="text-xs text-gray-600 italic">"{quote.text}"</p>
                      <p className="text-[10px] text-gray-400 mt-1">— {quote.attribution}</p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="flex justify-end gap-3 pt-4 border-t">
          <Button variant="outline" onClick={onClose} disabled={isPublishing}>
            Cancel
          </Button>
          <Button onClick={handlePublish} disabled={isPublishing}>
            {isPublishing ? 'Publishing...' : 'Publish to Network'}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**Step 2: Verify TypeScript compiles**

Run: `npx tsc --noEmit`

**Step 3: Commit**

```bash
git add src/components/career-stories/PublishModal.tsx
git commit -m "feat: add PublishModal with category picker and publish ceremony"
```

---

## Task 10: Wire PublishModal into NarrativePreview + CareerStoriesPage

Replace the tiny publish icon buttons with PublishModal trigger.

**Files:**
- Modify: `src/components/career-stories/NarrativePreview.tsx:1055-1098` (props), `1487-1495` (buttons)
- Modify: `src/components/career-stories/CareerStoriesPage.tsx` (modal state + handler)

**Step 1: Update NarrativePreview props**

In `NarrativePreview.tsx`, update the props interface (line 1055) to add `onOpenPublishModal`:

```typescript
interface NarrativePreviewProps {
  // ... existing props ...
  onOpenPublishModal?: () => void;  // NEW: opens PublishModal
  onCategoryChange?: (category: string) => void;  // NEW: change category on published story
}
```

Add the new props to destructuring (around line 1091):

```typescript
  onOpenPublishModal,
  onCategoryChange,
```

**Step 2: Replace publish icon buttons with proper buttons**

In `NarrativePreview.tsx`, replace lines 1487-1495:

```tsx
// BEFORE (lines 1487-1495)
{story?.isPublished ? (
  <button onClick={() => onUnpublish?.()} disabled={isPublishing} className="p-1.5 rounded text-green-500 hover:bg-green-50" title="Unpublish">
    <CheckCircle2 className="h-3.5 w-3.5" />
  </button>
) : onPublish && (
  <button onClick={() => onPublish('private', edits)} disabled={isPublishing} className="p-1.5 rounded text-gray-400 hover:bg-gray-100" title="Publish">
    <Share2 className="h-3.5 w-3.5" />
  </button>
)}

// AFTER
{story?.isPublished ? (
  <button onClick={() => onUnpublish?.()} disabled={isPublishing} className="p-1.5 rounded text-green-500 hover:bg-green-50" title="Unpublish">
    <CheckCircle2 className="h-3.5 w-3.5" />
  </button>
) : onOpenPublishModal && (
  <button onClick={onOpenPublishModal} disabled={isPublishing} className="p-1.5 rounded text-gray-400 hover:bg-gray-100" title="Publish">
    <Share2 className="h-3.5 w-3.5" />
  </button>
)}
```

**Step 3: Add PublishModal state and handler in CareerStoriesPage**

In `src/components/career-stories/CareerStoriesPage.tsx`:

Add import:
```typescript
import { PublishModal } from './PublishModal';
import { BragDocCategory } from '../../types/career-stories';
```

Add state (near the formatSwitchStoryId state, ~line 156):
```typescript
const [publishModalStoryId, setPublishModalStoryId] = useState<string | null>(null);
```

Add handler:
```typescript
const handlePublishWithCategory = async (category: BragDocCategory) => {
  if (!publishModalStoryId) return;
  // First set category via API (needs endpoint or combine with publish)
  await publishMutation.mutateAsync({ id: publishModalStoryId, visibility: 'network' as StoryVisibility });
  // TODO: Set category via separate PATCH or combine in publish endpoint
  setPublishModalStoryId(null);
};
```

Add modal render (near the FormatSwitchModal render):
```tsx
{publishModalStoryId && stories?.find(s => s.id === publishModalStoryId) && (
  <PublishModal
    isOpen={!!publishModalStoryId}
    onClose={() => setPublishModalStoryId(null)}
    story={stories.find(s => s.id === publishModalStoryId)!}
    onPublish={handlePublishWithCategory}
    isPublishing={publishMutation.isPending}
  />
)}
```

Pass the `onOpenPublishModal` prop to NarrativePreview:
```typescript
onOpenPublishModal={() => selectedStory && setPublishModalStoryId(selectedStory.id)}
```

**Step 4: Verify TypeScript compiles**

Run: `npx tsc --noEmit`

**Step 5: Commit**

```bash
git add src/components/career-stories/NarrativePreview.tsx src/components/career-stories/CareerStoriesPage.tsx
git commit -m "feat: wire PublishModal into NarrativePreview toolbar, replacing tiny icon buttons"
```

---

## Task 11: Update StoryCard StatusBadge — Published + Visibility

Update StatusBadge to show visibility indicator for published stories.

**Files:**
- Modify: `src/components/career-stories/StoryCard.tsx:31-63`

**Step 1: Update StatusBadge to show visibility**

In `StoryCard.tsx`, update the StatusBadge component:

```tsx
function StatusBadge({ isPublished, needsRegeneration, hasContent, visibility }: {
  isPublished: boolean;
  needsRegeneration?: boolean;
  hasContent?: boolean;
  visibility?: string;
}) {
  if (isPublished) {
    const isNetwork = visibility === 'network';
    return (
      <span className="inline-flex items-center gap-1 px-2 py-0.5 text-[10px] font-medium bg-green-100 text-green-700 rounded-full">
        <CheckCircle2 className="w-3 h-3" />
        Published{isNetwork ? ' · Network' : ''}
      </span>
    );
  }
  // ... rest stays the same (needsRegeneration, hasContent, Draft)
}
```

**Step 2: Pass visibility to StatusBadge**

Update the StatusBadge usage (around line 137):

```tsx
<StatusBadge
  isPublished={story.isPublished}
  needsRegeneration={story.needsRegeneration}
  hasContent={hasContent}
  visibility={story.visibility}
/>
```

**Step 3: Commit**

```bash
git add src/components/career-stories/StoryCard.tsx
git commit -m "feat: update StoryCard StatusBadge with visibility indicator for published stories"
```

---

## Task 12: Profile Page Rewiring — Career Stories Replace Journal Entries

Replace journal entries in profile "Published Work" tab with career stories organized by brag doc categories.

**Files:**
- Modify: `src/pages/profile/public-view.tsx`
- Modify: `src/services/career-stories.service.ts` (add getPublishedStories method if not present)
- Reference: `src/hooks/useCareerStories.ts` (existing hooks)

**Step 1: Add getPublishedStoriesForUser to frontend service**

In `src/services/career-stories.service.ts`, add:

```typescript
/**
 * Get published career stories for a user's profile
 */
static async getPublishedStories(userId: string): Promise<ApiResponse<{
  stories: CareerStory[];
  totalCount: number;
  viewerAccess: string;
}>> {
  const response = await api.get<ApiResponse<{ stories: CareerStory[]; totalCount: number; viewerAccess: string }>>(
    `/career-stories/users/${userId}/published-stories`
  );
  return response.data;
}
```

**Step 2: Update public-view.tsx to show career stories**

In `src/pages/profile/public-view.tsx`:

Add imports:
```typescript
import { CareerStoriesService } from '../../services/career-stories.service';
import { CareerStory, BragDocCategory } from '../../types/career-stories';
import { BRAG_DOC_CATEGORIES } from '../../components/career-stories/constants';
```

Replace the journal entries state and fetch with career stories:

```typescript
// Replace journalEntries state
const [publishedStories, setPublishedStories] = useState<CareerStory[]>([]);
const [isLoadingStories, setIsLoadingStories] = useState(false);

// Add fetch function
const fetchPublishedStories = async (profileUserId: string) => {
  setIsLoadingStories(true);
  try {
    const response = await CareerStoriesService.getPublishedStories(profileUserId);
    if (response.success && response.data) {
      setPublishedStories(response.data.stories);
    }
  } catch (error) {
    console.error('Failed to fetch published stories:', error);
  } finally {
    setIsLoadingStories(false);
  }
};
```

Replace the "Published Work" tab content with categorized career stories:

```tsx
{/* Published Work / Brag Document */}
<Tabs.Content value="published-work" className="space-y-6">
  {isLoadingStories ? (
    <div className="text-center py-8 text-gray-500">Loading stories...</div>
  ) : publishedStories.length === 0 ? (
    <div className="text-center py-8 text-gray-500">No published stories yet.</div>
  ) : (
    BRAG_DOC_CATEGORIES.map((cat) => {
      const stories = publishedStories.filter(s => s.category === cat.value);
      if (stories.length === 0) return null;
      return (
        <div key={cat.value} className="space-y-3">
          <h3 className="text-sm font-semibold text-gray-700">{cat.label}</h3>
          <div className="space-y-2">
            {stories.map((story) => (
              <div key={story.id} className="p-3 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors">
                <div className="flex items-center gap-2">
                  <h4 className="text-sm font-medium text-gray-900">{story.title}</h4>
                  <span className="px-1.5 py-0.5 text-[10px] font-medium bg-gray-100 text-gray-600 rounded">
                    {story.framework}
                  </span>
                </div>
                {story.sections && Object.values(story.sections)[0]?.summary && (
                  <p className="text-xs text-gray-600 mt-1 line-clamp-2">
                    {Object.values(story.sections)[0].summary}
                  </p>
                )}
              </div>
            ))}
          </div>
        </div>
      );
    })
  )}
</Tabs.Content>
```

**Step 3: Verify TypeScript compiles**

Run: `npx tsc --noEmit`

**Step 4: Commit**

```bash
git add src/pages/profile/public-view.tsx src/services/career-stories.service.ts
git commit -m "feat: rewire profile Published Work tab to show career stories by brag doc category"
```

---

## Task 13: Network Feed Page

Create a feed showing stories from followed users.

**Files:**
- Create: `src/components/network/NetworkFeed.tsx`
- Modify: `src/services/career-stories.service.ts` (add feed endpoint)
- Modify: Backend: add feed endpoint to routes

**Step 1: Add feed endpoint to backend**

In `backend/src/routes/network.routes.ts`, add:

```typescript
// Network feed: stories from people I follow
router.get('/feed', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const page = parseInt(req.query.page as string) || 1;
    const pageSize = parseInt(req.query.pageSize as string) || 20;

    // Get IDs of users I follow
    const follows = await prisma.follow.findMany({
      where: { followerId: userId },
      select: { followingId: true },
    });
    const followingIds = follows.map(f => f.followingId);

    if (followingIds.length === 0) {
      return sendSuccess(res, { stories: [], total: 0, page, pageSize });
    }

    const [stories, total] = await Promise.all([
      prisma.careerStory.findMany({
        where: {
          userId: { in: followingIds },
          isPublished: true,
          visibility: 'network',
        },
        orderBy: { publishedAt: 'desc' },
        skip: (page - 1) * pageSize,
        take: pageSize,
        include: {
          user: { select: { id: true, name: true, email: true } },
        },
      }),
      prisma.careerStory.count({
        where: {
          userId: { in: followingIds },
          isPublished: true,
          visibility: 'network',
        },
      }),
    ]);

    sendSuccess(res, { stories, total, page, pageSize });
  } catch (error) {
    console.error('Error fetching feed:', error);
    sendError(res, 'Failed to fetch feed', 500);
  }
});

// Suggested users (most active publishers)
router.get('/suggested-users', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const limit = parseInt(req.query.limit as string) || 20;

    // Get IDs of users already followed
    const follows = await prisma.follow.findMany({
      where: { followerId: userId },
      select: { followingId: true },
    });
    const excludeIds = [userId, ...follows.map(f => f.followingId)];

    // Find users with most published network stories
    const suggestions = await prisma.careerStory.groupBy({
      by: ['userId'],
      where: {
        isPublished: true,
        visibility: 'network',
        userId: { notIn: excludeIds },
      },
      _count: { id: true },
      orderBy: { _count: { id: 'desc' } },
      take: limit,
    });

    // Fetch user details
    const userIds = suggestions.map(s => s.userId);
    const users = await prisma.user.findMany({
      where: { id: { in: userIds } },
      select: { id: true, name: true, email: true },
    });

    const result = suggestions.map(s => ({
      user: users.find(u => u.id === s.userId),
      publishedCount: s._count.id,
    }));

    sendSuccess(res, { suggestions: result });
  } catch (error) {
    console.error('Error fetching suggested users:', error);
    sendError(res, 'Failed to fetch suggestions', 500);
  }
});
```

**Step 2: Create NetworkFeed frontend component**

Create `src/components/network/NetworkFeed.tsx` — a basic feed page that fetches stories from followed users and shows suggested users when empty. This is a new page component; wire it into routing separately.

**Step 3: Commit**

```bash
git add backend/src/routes/network.routes.ts src/components/network/NetworkFeed.tsx
git commit -m "feat: add network feed endpoint + suggested users + frontend feed component"
```

---

## Task 14: Archetype + Role Badges in NarrativePreview

Show archetype and role badges in the NarrativePreview detail panel header.

**Files:**
- Modify: `src/components/career-stories/NarrativePreview.tsx` (header area)

**Step 1: Add badges to NarrativePreview header**

Find the header section in NarrativePreview where the framework badge is shown and add archetype + role badges:

```tsx
{story?.archetype && (
  <span className="px-1.5 py-0.5 rounded text-xs font-medium bg-purple-50 text-purple-700 capitalize">
    {story.archetype}
  </span>
)}
{story?.role && (
  <span className="px-1.5 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-700 capitalize">
    {story.role}
  </span>
)}
```

**Step 2: Commit**

```bash
git add src/components/career-stories/NarrativePreview.tsx
git commit -m "feat: show archetype and role badges in NarrativePreview detail header"
```

---

## Task 15: Archetype Picker in FormatSwitchModal

Add archetype selection alongside framework and style in FormatSwitchModal.

**Files:**
- Modify: `src/components/career-stories/FormatSwitchModal.tsx`

**Step 1: Add archetype state and picker UI**

Import archetype constants:
```typescript
import { ARCHETYPE_METADATA, ARCHETYPE_GROUPS, ArchetypeGroup } from './constants';
import { StoryArchetype } from '../../types/career-stories';
```

Add archetype state (near other form state):
```typescript
const [selectedArchetype, setSelectedArchetype] = useState<StoryArchetype | undefined>(
  story.archetype || undefined
);
```

Add archetype picker in the modal body, after the style section:

```tsx
{/* Archetype picker */}
<div className="space-y-2">
  <label className="text-sm font-medium text-gray-700">Narrative Angle</label>
  <div className="space-y-3">
    {(Object.entries(ARCHETYPE_GROUPS) as [ArchetypeGroup, typeof ARCHETYPE_GROUPS[ArchetypeGroup]][]).map(
      ([groupKey, group]) => (
        <div key={groupKey}>
          <div className="text-xs font-medium text-gray-500 mb-1">{group.label}</div>
          <div className="flex flex-wrap gap-1.5">
            {group.archetypes.map((arch) => {
              const meta = ARCHETYPE_METADATA[arch];
              return (
                <button
                  key={arch}
                  onClick={() => setSelectedArchetype(arch as StoryArchetype)}
                  className={cn(
                    'px-2 py-1 rounded text-xs transition-colors',
                    selectedArchetype === arch
                      ? 'bg-purple-100 text-purple-700 font-medium'
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  )}
                  title={meta?.description}
                >
                  {arch.charAt(0).toUpperCase() + arch.slice(1)}
                </button>
              );
            })}
          </div>
        </div>
      )
    )}
  </div>
</div>
```

**Step 2: Pass archetype to onRegenerate callback**

Update the regenerate call to include archetype. The `onRegenerate` prop signature may need to be extended to accept archetype.

**Step 3: Verify TypeScript compiles**

Run: `npx tsc --noEmit`

**Step 4: Commit**

```bash
git add src/components/career-stories/FormatSwitchModal.tsx
git commit -m "feat: add archetype picker to FormatSwitchModal alongside framework and style"
```

---

## Task Summary

| # | Task | Type | Estimated Steps |
|---|---|---|---|
| 1 | Visibility alignment | Rename | 5 |
| 2 | DB migration — new columns | Schema | 6 |
| 3 | DB migration — Follow model | Schema | 4 |
| 4 | Follow service + tests | Backend | 5 |
| 5 | Follow API routes | Backend | 3 |
| 6 | Archetype + journalEntryId on create | Backend | 7 |
| 7 | PublishedStory API response | Backend + Test | 6 |
| 8 | Frontend types + constants | Frontend | 5 |
| 9 | PublishModal component | Frontend | 3 |
| 10 | Wire PublishModal | Frontend | 5 |
| 11 | StoryCard StatusBadge | Frontend | 3 |
| 12 | Profile page rewiring | Frontend | 4 |
| 13 | Network feed + suggested users | Full stack | 3 |
| 14 | Archetype/role badges in preview | Frontend | 2 |
| 15 | Archetype in FormatSwitchModal | Frontend | 4 |

**Total: 15 tasks, ~65 steps.**

Tasks 1-7 are backend-first (can be done in sequence).
Tasks 8-15 are frontend (9 depends on 8, 10 depends on 9, rest can parallel).
